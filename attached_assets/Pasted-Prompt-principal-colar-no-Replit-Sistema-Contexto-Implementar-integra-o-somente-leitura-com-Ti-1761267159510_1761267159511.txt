Prompt principal (colar no Replit)

Sistema/Contexto:

Implementar integração somente leitura com Tiny ERP.

Respeitar os 3 modos de uso descritos na visão geral.

Tarefas:

Criar tinyService com:

getProductBySKU({ tokenLabel, sku }): Promise<ProductData>

validateToken({ tokenLabel }): Promise<boolean>

mapTinyToProductData(raw): mapeia resposta do Tiny para { title, sku, gtin, height_cm, width_cm, length_cm, weight_kg, cost_price }.

Config: Persistir uma lista de tokens { label, token }. Expor no Settings UI tabela CRUD (Create/Read/Update/Delete) com validação básica.

Fluxo na tela inicial:

Se SKU preenchido → chamar getProductBySKU usando o token da instância selecionada.

Preencher automaticamente o campo Produto com title retornado.

Atualizar estado global (ou store) com { gtin, sku, height_cm, width_cm, length_cm, weight_kg, cost_price }.

Injetar height_cm, width_cm, length_cm, weight_kg no prompt da LLM (override de qualquer outra fonte).

Resiliência:

Timeout e retry exponencial (máx. 2 tentativas).

Tratamento de erros de autenticação (token inválido/expirado) e de inexistência de SKU.

Logs estruturados e eventos de telemetria.

Segurança:

Nunca logar tokens.

Armazenar tokens de forma segura (seguir padrão já existente no app para secrets/configs).

Entrega esperada:

UI da Etapa 1 intacta.

Ao informar label + SKU, dados reais do Tiny preenchem campos e seções (agora sem placeholders).

Dimensões e peso sempre injetados na LLM como fonte confiável.

Critérios de aceite (Etapa 2)

Testes sugeridos (Etapa 2)

Happy path com SKU válido → dados mapeados corretamente.

SKU inexistente → mensagem amigável; campos não são preenchidos; manter modo manual.

Token inválido → erro claro; sugerir revisar Settings.

Timeout → retry 2×; se falhar, cair para modo manual com aviso não intrusivo.

Campos com valores zero/nulos no Tiny → fallback para edição manual apenas desses campos, mantendo os demais bloqueados.

Checklist de QA (Etapa 2)

Não vazar token em logs/erros.

Campos numéricos com unidades corretas (cm/kg).

Persistência de dados para sessões posteriores (seguir padrão já existente do app).

