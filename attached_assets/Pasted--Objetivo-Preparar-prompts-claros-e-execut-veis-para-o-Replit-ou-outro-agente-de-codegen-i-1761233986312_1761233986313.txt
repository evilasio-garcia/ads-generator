# Objetivo

Preparar **prompts claros e executáveis** para o Replit (ou outro agente de codegen) implementar uma evolução do seu app de criação de anúncios multi‑marketplaces, em **3 etapas** independentes e idempotentes, sem quebrar o comportamento atual.

> **Importante**: Este documento não entrega código. Ele define prompts, critérios de aceite, testes e contratos que o agente deverá seguir ao gerar o código.

---

## Visão Geral (escopo)

* Integrar com **Olist Tiny (Tiny ERP)** para ler dados de **Produtos** (nome/título, dimensões AxLxC, peso, custo, GTIN/EAN) e usar **peso e dimensões** como fonte **confiável** nas LLMs (sobrescrevendo qualquer outra fonte). Demais infos ficam persistidas para uso em sessões posteriores e para telas novas.
* Adicionar **Config** para múltiplos **tokens** Tiny: tabela com `label` (ex.: "Tiny SC", "Tiny SP") + `token`.
* Na **tela inicial**, inserir **combo de ERP** e **campo SKU** **antes** do campo de produto.
* **Modos de uso**:

  1. **Sem token Tiny configurado** → combo ERP e SKU **desabilitados**; fluxo atual **inalterado** (usuário digita Produto manualmente).
  2. **Com token Tiny configurado, mas SKU em branco** → fluxo **inalterado** (usuário digita Produto).
  3. **Com token Tiny configurado e SKU preenchido** → antes de chamar LLM: buscar no Tiny **Título**, **Dimensões (A×L×C)**, **Peso**, **Custo**, **GTIN/EAN**; preencher **Produto** automaticamente; injetar **Peso** e **Dimensões** no prompt da LLM; armazenar demais dados para telas novas.
* Ao fim da tela atual, criar duas novas **seções**:

  * **Informações cadastrais**: campos editáveis `GTIN/EAN`, `SKU`, `Altura`, `Largura`, `Comprimento`, `Peso`.
  * **Informações de preço**: `Custo base`, `Preço anúncio`, `Faixas de preço por atacado` (tabela `#` e `$`), `Preço agressivo`, `Preço promocional`.
* **Comportamento das novas seções**:

  * **Integração ativa** (Tiny em uso) → **auto‑preencher** e **desabilitar** inputs; cada input com botão **"Copiar conteúdo"** (mesmo ícone/estilo já usado em outras partes do app).
  * **Modo manual** (sem Tiny ou SKU vazio) → inputs **editáveis**; cada input com botão **"Copiar conteúdo"** (mesmo ícone/estilo já usado em outras partes do app).

---

# Como usar este Prompt Pack

Para cada etapa há **um prompt principal** (para colar no Replit) e anexos: **critérios de aceite**, **contratos de UI/UX**, **telemetria**, **testes** e **checklist de QA**. Execute **uma etapa por vez**. Cada etapa deve ser **idempotente** e preservar o que já existe.

---

## Etapa 1 — Somente UI/UX (sem chamadas à API Tiny)

**Objetivo:** Entregar todos os **elementos de interface** prontos, com estados, validações e lógica de habilitar/desabilitar, **sem integração externa**.

### Prompt principal (colar no Replit)

> **Sistema/Contexto (não gerar código fora desse escopo):**
>
> * Você irá **apenas** criar/alterar **UI/UX** e lógica de estado local. **Não** faça chamadas a APIs externas.
> * Preserve o comportamento atual do app quando a integração Tiny não estiver configurada ou o SKU estiver em branco.
> * Não remova nem altere componentes fora das áreas explicitamente citadas.
>
> **Tarefas:**
>
> 1. Na tela inicial, **inserir antes** do campo "Produto" uma seção "Origem de dados":
>
>    * **Select/Combo de Instância** (lista de labels configurados no Settings → Tokens Tiny). Se não houver tokens, mostrar placeholder `Nenhuma instância Tiny cadastrada` e **desabilitar**.
>    * **Input SKU** (placeholder: `Digite o SKU do Tiny`). Regra: **desabilitado** se não houver tokens Tiny.
> 2. Regras de habilitação:
>
>    * **Sem tokens Tiny**: `ERP = Tiny ERP` e `SKU` **desabilitados**; manter fluxo **Manual**.
>    * **Com tokens Tiny**: usuário pode escolher qual label (instância tiny); se `SKU` **vazio** → fluxo atual (manual); se `SKU` **preenchido** → marcar estado local `integrationMode = tiny`.
> 3. Prepara duas novas seções **no final da tela**:
>
>    * **Informações cadastrais**: `GTIN/EAN`, `SKU`, `Altura`, `Largura`, `Comprimento`, `Peso`.
>    * **Informações de preço**: `Custo base`, `Preço anúncio`, tabela `Faixas de preço por atacado` (colunas `#` e `$`), `Preço agressivo`, `Preço promocional`.
> 4. Comportamentos das novas seções:
>
>    * Se `integrationMode = tiny` **ativo** → inputs **auto‑preenchidos com placeholders simulados** e **desabilitados**.
>    * Caso contrário (modo manual) → inputs **editáveis**.
>    * Em **todos** os inputs, inserir um botão discreto à direita: ícone de copiar + label `Copiar conteúdo` com o **mesmo estilo** já usado no app.
> 5. Não implementar lógica de preço ainda; apenas os campos e a tabela.
>
> **Entrega esperada (sem código sensível):**
>
> * Componentes UI adicionados.
> * Lógica de habilitar/desabilitar conforme regras.
> * Placeholders realistas para dados vindos do Tiny.
> * Nenhuma chamada externa.

### Critérios de aceite (Etapa 1)

### Testes sugeridos (Etapa 1)

1. **Sem tokens Tiny** → garantir desabilitado + fluxo manual intacto.
2. **Com tokens** + `ERP=Tiny` + `SKU vazio` → fluxo manual intacto.
3. **Com tokens** + `ERP=Tiny` + `SKU preenchido` → novas seções bloqueadas com dados simulados.
4. Botão **Copiar conteúdo** copia exatamente o valor do campo.

### Checklist de QA (Etapa 1)

* Alinhamento visual consistente; nada do layout original fora da área indicada deve ser alterado.
* Placeholders de dados têm formato coerente (GTIN com 8/12/13/14 dígitos; dimensões numéricas positivas; peso > 0).
* A tabela de atacado permite adicionar/remover linhas no modo manual.

---

## Etapa 2 — Integração funcional com Tiny (leitura de produto)

**Objetivo:** Ativar a integração com o Tiny para buscar **Título**, **Dimensões (A×L×C)**, **Peso**, **Custo**, **GTIN/EAN** a partir do **SKU** e da **instância** (token) selecionados.

> **Observação**: Use um **Service/Adapter** dedicado `tinyService` com funções puras. Centralize mapeamentos, paginação e parsing. Consulte a **documentação oficial do Tiny** para endpoints e formatos (não hardcode exemplos não oficiais).

### Prompt principal (colar no Replit)

> **Sistema/Contexto:**
>
> * Implementar integração **somente leitura** com Tiny ERP.
> * Respeitar os 3 modos de uso descritos na visão geral.
>
> **Tarefas:**
>
> 1. Criar `tinyService` com:
>
>    * `getProductBySKU({ tokenLabel, sku }): Promise<ProductData>`
>    * `validateToken({ tokenLabel }): Promise<boolean>`
>    * `mapTinyToProductData(raw)`: mapeia resposta do Tiny para `{ title, sku, gtin, height_cm, width_cm, length_cm, weight_kg, cost_price }`.
> 2. **Config**: Persistir uma lista de tokens `{ label, token }`. Expor no Settings UI tabela CRUD (Create/Read/Update/Delete) com validação básica.
> 3. Fluxo na tela inicial:
>
>    * Se `ERP = Tiny ERP` e `SKU` preenchido → chamar `getProductBySKU` usando o **token** da instância selecionada.
>    * Preencher automaticamente o campo **Produto** com `title` retornado.
>    * Atualizar estado global (ou store) com `{ gtin, sku, height_cm, width_cm, length_cm, weight_kg, cost_price }`.
>    * **Injetar** `height_cm`, `width_cm`, `length_cm`, `weight_kg` no **prompt da LLM** (override de qualquer outra fonte).
> 4. **Resiliência**:
>
>    * Timeout e retry exponencial (máx. 2 tentativas).
>    * Tratamento de erros de autenticação (token inválido/expirado) e de inexistência de SKU.
>    * Logs estruturados e eventos de telemetria.
> 5. **Segurança**:
>
>    * Nunca logar tokens.
>    * Armazenar tokens de forma segura (seguir padrão já existente no app para secrets/configs).
>
> **Entrega esperada:**
>
> * UI da Etapa 1 intacta.
> * Ao informar `ERP = Tiny ERP` + `SKU`, dados reais do Tiny preenchem campos e seções (agora sem placeholders).
> * Dimensões e peso **sempre** injetados na LLM como fonte confiável.

### Critérios de aceite (Etapa 2)

*

### Telemetria (Etapa 2)

* `integration.tiny.get_product.start` { sku, tokenLabel }
* `integration.tiny.get_product.success` { sku, tokenLabel, ms }
* `integration.tiny.get_product.error` { sku, tokenLabel, code }
* `integration.tiny.token.added/updated/deleted` { tokenLabel }

### Testes sugeridos (Etapa 2)

1. **Happy path** com SKU válido → dados mapeados corretamente.
2. **SKU inexistente** → mensagem amigável; campos não são preenchidos; manter modo manual.
3. **Token inválido** → erro claro; sugerir revisar Settings.
4. **Timeout** → retry 2×; se falhar, cair para modo manual com aviso não intrusivo.
5. **Campos com valores zero/nulos** no Tiny → fallback para edição manual **apenas** desses campos, mantendo os demais bloqueados.

### Checklist de QA (Etapa 2)

* Não vazar token em logs/erros.
* Campos numéricos com unidades corretas (cm/kg).
* Persistência de dados para sessões posteriores (seguir padrão já existente do app).

---

## Etapa 3 — Engine de Preços (funções puras)

**Objetivo:** Entregar um **mecanismo extensível** de cálculo de preços baseado em **funções puras**, recebendo somente `cost_price` e `marketplace` (e, opcionalmente, um contexto configurável), gerando **Preço anúncio**, **Faixas de atacado**, **Preço agressivo** e **Preço promocional**.

### Prompt principal (colar no Replit)

> **Sistema/Contexto:**
>
> * Criar módulo `pricingEngine` com funções determinísticas e testáveis. **Sem** chamadas de rede.
>
> **Tarefas:**
>
> 1. API proposta:
>
>    * `getListingPrice({ cost_price, marketplace, ctx? }): number`
>    * `getWholesaleTiers({ cost_price, marketplace, ctx? }): Array<{ tier: number, price: number }>`
>    * `getAggressivePrice({ cost_price, marketplace, ctx? }): number`
>    * `getPromoPrice({ cost_price, marketplace, ctx? }): number`
> 2. `ctx` deve aceitar políticas por marketplace (ex.: markups mínimos, taxas esperadas, arredondamento psicológico, limites por categoria, metas de margem/contribuição, regras regionais, etc.).
> 3. Todos outputs devem ser **não negativos**, com arredondamento configurável (ex.: para `,99`).
> 4. Injetar os resultados nas seções de **Informações de preço**. No modo Tiny ativo, campos permanecem **desabilitados** (somente leitura). No modo manual, usuário pode sobrescrever manualmente (sem alterar a engine).
> 5. Expor **hooks**/callbacks (ou events) para permitir auditoria/explicabilidade do cálculo (ex.: breakdown de custos/fees/markup aplicado).
>
> **Entrega esperada:**
>
> * Engine isolada, com **testes unitários** cobrindo as funções.
> * UI reflete os valores calculados; edição manual possível apenas no modo manual.

### Critérios de aceite (Etapa 3)

*

### Telemetria (Etapa 3)

* `pricing.calculate` { marketplace, cost_price, policy_id }
* `pricing.override_manual` { field_id, old, new }

### Testes sugeridos (Etapa 3)

1. **Marketplace A vs B** com mesmo custo → preços distintos conforme políticas.
2. **Custo muito baixo** → aplicar preço mínimo; não quebrar.
3. **Arredondamento** → validar finais `,99` quando habilitado.
4. **Faixas atacado** → validar tiers e monotonicidade decrescente do preço por unidade.

### Checklist de QA (Etapa 3)

* Engine sem dependências externas.
* Mudança de `ctx` reflete imediatamente nos cálculos.
* UI bloqueia edição no modo Tiny e permite no manual.

---

## Contrato de dados (ProductData)

```json
{
  "title": "string",
  "sku": "string",
  "gtin": "string | null",
  "height_cm": 0,
  "width_cm": 0,
  "length_cm": 0,
  "weight_kg": 0,
  "cost_price": 0
}
```

## Regras de UX importantes

* **Não** alterar componentes fora do escopo.
* Estados visuais claros para **desabilitado** vs **editável**.
* Botão **Copiar conteúdo** consistente com padrão existente.
* Mensagens de erro **não bloqueantes** (snackbar/toast), com caminhos de recuperação.

## Observações finais

* Caso a documentação do Tiny exija headers, formatos específicos ou paginação, **centralizar** no `tinyService`.
* Preparar **mocks** para Etapas 1 e 3; e testes de integração na Etapa 2 com ambientes/stubs.
* Toda alteração deve ser **idempotente** e protegida por **feature flag** onde indicado.
